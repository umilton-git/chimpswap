{"ast":null,"code":"'use strict';\n\nconst mh = require('multihashes');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec');\n\nconst codecs = require('multicodec/src/base-table.json');\n\nconst CIDUtil = require('./cid-util');\n\nconst withIs = require('class-is');\n\nconst uint8ArrayConcat = require('uint8arrays/concat');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst codecInts = Object.keys(codecs).reduce((p, name) => {\n  p[codecs[name]] = name;\n  return p;\n}, {});\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Uint8Array} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\n\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Uint8Array|CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor(version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = cid.multihash; // Default guard for when a CID < 0.7 is passed with no multibaseName\n\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version);\n\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version);\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16);\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n\n    if (version instanceof Uint8Array) {\n      const firstByte = version.slice(0, 1);\n      const v = parseInt(firstByte.toString('hex'), 16);\n\n      if (v === 1) {\n        // version is a CID Uint8Array\n        const cid = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      return;\n    } // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n\n\n    this.version = version;\n\n    if (typeof codec === 'number') {\n      codec = codecInts[codec];\n    }\n    /**\n     * @type {string}\n     */\n\n\n    this.codec = codec;\n    /**\n     * @type {Uint8Array}\n     */\n\n    this.multihash = multihash;\n    /**\n     * @type {string}\n     */\n\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n  /**\n   * The CID as a `Uint8Array`\n   *\n   * @return {Uint8Array}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n\n\n  get bytes() {\n    let bytes = this._bytes;\n\n    if (!bytes) {\n      if (this.version === 0) {\n        bytes = this.multihash;\n      } else if (this.version === 1) {\n        const codec = multicodec.getCodeVarint(this.codec);\n        bytes = uint8ArrayConcat([[1], codec, this.multihash], 1 + codec.byteLength + this.multihash.byteLength);\n      } else {\n        throw new Error('unsupported version');\n      } // Cache this Uint8Array so it doesn't have to be recreated\n\n\n      Object.defineProperty(this, '_bytes', {\n        value: bytes\n      });\n    }\n\n    return bytes;\n  }\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Uint8Array}\n   * @readonly\n   */\n\n\n  get prefix() {\n    const codec = multicodec.getCodeVarint(this.codec);\n    const multihash = mh.prefix(this.multihash);\n    const prefix = uint8ArrayConcat([[this.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n    return prefix;\n  }\n\n  get code() {\n    return codecs[this.codec];\n  }\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n\n\n  toV0() {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n    }\n\n    const {\n      name,\n      length\n    } = mh.decode(this.multihash);\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n    }\n\n    return new _CID(0, this.codec, this.multihash);\n  }\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n\n\n  toV1() {\n    return new _CID(1, this.codec, this.multihash);\n  }\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n\n\n  toBaseEncodedString(base = this.multibaseName) {\n    if (this.string && base === this.multibaseName) {\n      return this.string;\n    }\n\n    let str = null;\n\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n      }\n\n      str = mh.toB58String(this.multihash);\n    } else if (this.version === 1) {\n      str = uint8ArrayToString(multibase.encode(base, this.bytes));\n    } else {\n      throw new Error('unsupported version');\n    }\n\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', {\n        value: str\n      });\n    }\n\n    return str;\n  }\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {String}\n   */\n\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n\n  toString(base) {\n    return this.toBaseEncodedString(base);\n  }\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n\n\n  toJSON() {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    };\n  }\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n\n\n  equals(other) {\n    return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);\n  }\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n\n\n  static validateCID(other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other);\n\n    if (errorMsg) {\n      throw new Error(errorMsg);\n    }\n  }\n\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n});\n\n_CID.codecs = codecs;\nmodule.exports = _CID;","map":{"version":3,"sources":["C:/Users/Ulyss/chimpswap/uniswap-interface-main/node_modules/cids/src/index.js"],"names":["mh","require","multibase","multicodec","codecs","CIDUtil","withIs","uint8ArrayConcat","uint8ArrayToString","uint8ArrayEquals","codecInts","Object","keys","reduce","p","name","CID","constructor","version","codec","multihash","multibaseName","_CID","isCID","cid","baseName","isEncoded","decode","parseInt","slice","toString","getCodec","rmPrefix","fromB58String","validateCID","defineProperty","value","Uint8Array","firstByte","v","bytes","_bytes","getCodeVarint","byteLength","Error","prefix","code","toV0","length","toV1","toBaseEncodedString","base","string","str","toB58String","encode","Symbol","for","toJSON","hash","equals","other","errorMsg","checkCIDComponents","className","symbolName","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst codecs = require('multicodec/src/base-table.json')\nconst CIDUtil = require('./cid-util')\nconst withIs = require('class-is')\nconst uint8ArrayConcat = require('uint8arrays/concat')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\nconst codecInts = Object.keys(codecs).reduce((p, name) => {\n  p[codecs[name]] = name\n  return p\n}, {})\n\n/**\n * @typedef {Object} SerializedCID\n * @param {string} codec\n * @param {number} version\n * @param {Uint8Array} multihash\n */\n\n/**\n * Test if the given input is a CID.\n * @function isCID\n * @memberof CID\n * @static\n * @param {any} other\n * @returns {bool}\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {string|Uint8Array|CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor (version, codec, multihash, multibaseName) {\n    if (_CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = version\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = cid.multihash\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\n      return\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version)\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version)\n        this.version = parseInt(cid.slice(0, 1).toString('hex'), 16)\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = baseName\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = mh.fromB58String(version)\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      Object.defineProperty(this, 'string', { value: version })\n      return\n    }\n\n    if (version instanceof Uint8Array) {\n      const firstByte = version.slice(0, 1)\n      const v = parseInt(firstByte.toString('hex'), 16)\n      if (v === 1) {\n        // version is a CID Uint8Array\n        const cid = version\n        this.version = v\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = 'base32'\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = version\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      return\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    /**\n     * @type {number}\n     */\n    this.version = version\n\n    if (typeof codec === 'number') {\n      codec = codecInts[codec]\n    }\n\n    /**\n     * @type {string}\n     */\n    this.codec = codec\n\n    /**\n     * @type {Uint8Array}\n     */\n    this.multihash = multihash\n\n    /**\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Uint8Array`\n   *\n   * @return {Uint8Array}\n   * @readonly\n   *\n   * @memberOf CID\n   */\n  get bytes () {\n    let bytes = this._bytes\n\n    if (!bytes) {\n      if (this.version === 0) {\n        bytes = this.multihash\n      } else if (this.version === 1) {\n        const codec = multicodec.getCodeVarint(this.codec)\n        bytes = uint8ArrayConcat([\n          [1], codec, this.multihash\n        ], 1 + codec.byteLength + this.multihash.byteLength)\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this Uint8Array so it doesn't have to be recreated\n      Object.defineProperty(this, '_bytes', { value: bytes })\n    }\n\n    return bytes\n  }\n\n  /**\n   * Get the prefix of the CID.\n   *\n   * @returns {Uint8Array}\n   * @readonly\n   */\n  get prefix () {\n    const codec = multicodec.getCodeVarint(this.codec)\n    const multihash = mh.prefix(this.multihash)\n    const prefix = uint8ArrayConcat([\n      [this.version], codec, multihash\n    ], 1 + codec.byteLength + multihash.byteLength)\n\n    return prefix\n  }\n\n  get code () {\n    return codecs[this.codec]\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new _CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new _CID(1, this.codec, this.multihash)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {string} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base = this.multibaseName) {\n    if (this.string && base === this.multibaseName) {\n      return this.string\n    }\n    let str = null\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n      }\n      str = mh.toB58String(this.multihash)\n    } else if (this.version === 1) {\n      str = uint8ArrayToString(multibase.encode(base, this.bytes))\n    } else {\n      throw new Error('unsupported version')\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', { value: str })\n    }\n    return str\n  }\n\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {String}\n   */\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return 'CID(' + this.toString() + ')'\n  }\n\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {bool}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      uint8ArrayEquals(this.multihash, other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other\n   * @returns {void}\n   */\n  static validateCID (other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n}\n\nconst _CID = withIs(CID, {\n  className: 'CID',\n  symbolName: '@ipld/js-cid/CID'\n})\n\n_CID.codecs = codecs\n\nmodule.exports = _CID\n"]},"metadata":{},"sourceType":"script"}