{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Ulyss\\\\chimpswap\\\\uniswap-interface-main\\\\src\\\\pages\\\\Earn\\\\Countdown.tsx\";\nimport React, { useEffect, useMemo, useState } from 'react';\nimport { STAKING_GENESIS, REWARDS_DURATION_DAYS } from '../../state/stake/hooks';\nimport { TYPE } from '../../theme';\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst REWARDS_DURATION = DAY * REWARDS_DURATION_DAYS;\nexport function Countdown({\n  exactEnd\n}) {\n  // get end/beginning times\n  const end = useMemo(() => exactEnd ? Math.floor(exactEnd.getTime() / 1000) : STAKING_GENESIS + REWARDS_DURATION, [exactEnd]);\n  const begin = useMemo(() => end - REWARDS_DURATION, [end]); // get current time\n\n  const [time, setTime] = useState(() => Math.floor(Date.now() / 1000));\n  useEffect(() => {\n    // we only need to tick if rewards haven't ended yet\n    if (time <= end) {\n      const timeout = setTimeout(() => setTime(Math.floor(Date.now() / 1000)), 1000);\n      return () => {\n        clearTimeout(timeout);\n      };\n    }\n  }, [time, end]);\n  const timeUntilGenesis = begin - time;\n  const timeUntilEnd = end - time;\n  let timeRemaining;\n  let message;\n\n  if (timeUntilGenesis >= 0) {\n    message = 'Rewards begin in';\n    timeRemaining = timeUntilGenesis;\n  } else {\n    const ongoing = timeUntilEnd >= 0;\n\n    if (ongoing) {\n      message = 'Rewards end in';\n      timeRemaining = timeUntilEnd;\n    } else {\n      message = 'Rewards have ended!';\n      timeRemaining = Infinity;\n    }\n  }\n\n  const days = (timeRemaining - timeRemaining % DAY) / DAY;\n  timeRemaining -= days * DAY;\n  const hours = (timeRemaining - timeRemaining % HOUR) / HOUR;\n  timeRemaining -= hours * HOUR;\n  const minutes = (timeRemaining - timeRemaining % MINUTE) / MINUTE;\n  timeRemaining -= minutes * MINUTE;\n  const seconds = timeRemaining;\n  return /*#__PURE__*/React.createElement(TYPE.black, {\n    fontWeight: 400,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 5\n    }\n  }, message, ' ', Number.isFinite(timeRemaining) && /*#__PURE__*/React.createElement(\"code\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 9\n    }\n  }, `${days}:${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`));\n}","map":{"version":3,"sources":["C:/Users/Ulyss/chimpswap/uniswap-interface-main/src/pages/Earn/Countdown.tsx"],"names":["React","useEffect","useMemo","useState","STAKING_GENESIS","REWARDS_DURATION_DAYS","TYPE","MINUTE","HOUR","DAY","REWARDS_DURATION","Countdown","exactEnd","end","Math","floor","getTime","begin","time","setTime","Date","now","timeout","setTimeout","clearTimeout","timeUntilGenesis","timeUntilEnd","timeRemaining","message","ongoing","Infinity","days","hours","minutes","seconds","Number","isFinite","toString","padStart"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useState } from 'react'\nimport { STAKING_GENESIS, REWARDS_DURATION_DAYS } from '../../state/stake/hooks'\nimport { TYPE } from '../../theme'\n\nconst MINUTE = 60\nconst HOUR = MINUTE * 60\nconst DAY = HOUR * 24\nconst REWARDS_DURATION = DAY * REWARDS_DURATION_DAYS\n\nexport function Countdown({ exactEnd }: { exactEnd?: Date }) {\n  // get end/beginning times\n  const end = useMemo(() => (exactEnd ? Math.floor(exactEnd.getTime() / 1000) : STAKING_GENESIS + REWARDS_DURATION), [\n    exactEnd\n  ])\n  const begin = useMemo(() => end - REWARDS_DURATION, [end])\n\n  // get current time\n  const [time, setTime] = useState(() => Math.floor(Date.now() / 1000))\n  useEffect((): (() => void) | void => {\n    // we only need to tick if rewards haven't ended yet\n    if (time <= end) {\n      const timeout = setTimeout(() => setTime(Math.floor(Date.now() / 1000)), 1000)\n      return () => {\n        clearTimeout(timeout)\n      }\n    }\n  }, [time, end])\n\n  const timeUntilGenesis = begin - time\n  const timeUntilEnd = end - time\n\n  let timeRemaining: number\n  let message: string\n  if (timeUntilGenesis >= 0) {\n    message = 'Rewards begin in'\n    timeRemaining = timeUntilGenesis\n  } else {\n    const ongoing = timeUntilEnd >= 0\n    if (ongoing) {\n      message = 'Rewards end in'\n      timeRemaining = timeUntilEnd\n    } else {\n      message = 'Rewards have ended!'\n      timeRemaining = Infinity\n    }\n  }\n\n  const days = (timeRemaining - (timeRemaining % DAY)) / DAY\n  timeRemaining -= days * DAY\n  const hours = (timeRemaining - (timeRemaining % HOUR)) / HOUR\n  timeRemaining -= hours * HOUR\n  const minutes = (timeRemaining - (timeRemaining % MINUTE)) / MINUTE\n  timeRemaining -= minutes * MINUTE\n  const seconds = timeRemaining\n\n  return (\n    <TYPE.black fontWeight={400}>\n      {message}{' '}\n      {Number.isFinite(timeRemaining) && (\n        <code>\n          {`${days}:${hours.toString().padStart(2, '0')}:${minutes\n            .toString()\n            .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`}\n        </code>\n      )}\n    </TYPE.black>\n  )\n}\n"]},"metadata":{},"sourceType":"module"}