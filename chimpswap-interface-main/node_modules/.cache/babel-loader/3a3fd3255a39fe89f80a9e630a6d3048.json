{"ast":null,"code":"import { UNI } from './../../constants/index';\nimport { TokenAmount, JSBI } from '@uniswap/sdk';\nimport { useEffect, useState } from 'react';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMerkleDistributorContract } from '../../hooks/useContract';\nimport { useSingleCallResult } from '../multicall/hooks';\nimport { calculateGasMargin, isAddress } from '../../utils';\nimport { useTransactionAdder } from '../transactions/hooks';\nconst CLAIM_PROMISES = {}; // returns the claim for the given address, or null if not valid\n\nfunction fetchClaim(account, chainId) {\n  var _CLAIM_PROMISES$key;\n\n  const formatted = isAddress(account);\n  if (!formatted) return Promise.reject(new Error('Invalid address'));\n  const key = `${chainId}:${account}`;\n  return CLAIM_PROMISES[key] = (_CLAIM_PROMISES$key = CLAIM_PROMISES[key]) !== null && _CLAIM_PROMISES$key !== void 0 ? _CLAIM_PROMISES$key : fetch('https://merkle-drop-1.uniswap.workers.dev/', {\n    body: JSON.stringify({\n      chainId,\n      address: formatted\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n      'Referrer-Policy': 'no-referrer'\n    },\n    method: 'POST'\n  }).then(res => res.ok ? res.json() : console.log(`No claim for account ${formatted} on chain ID ${chainId}`)).catch(error => console.error('Failed to get claim data', error));\n} // parse distributorContract blob and detect if user has claim data\n// null means we know it does not\n\n\nexport function useUserClaimData(account) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const key = `${chainId}:${account}`;\n  const [claimInfo, setClaimInfo] = useState({});\n  useEffect(() => {\n    if (!account || !chainId) return;\n    fetchClaim(account, chainId).then(accountClaimInfo => setClaimInfo(claimInfo => {\n      return { ...claimInfo,\n        [key]: accountClaimInfo\n      };\n    }));\n  }, [account, chainId, key]);\n  return account && chainId ? claimInfo[key] : undefined;\n} // check if user is in blob and has not yet claimed UNI\n\nexport function useUserHasAvailableClaim(account) {\n  var _isClaimedResult$resu;\n\n  const userClaimData = useUserClaimData(account);\n  const distributorContract = useMerkleDistributorContract();\n  const isClaimedResult = useSingleCallResult(distributorContract, 'isClaimed', [userClaimData === null || userClaimData === void 0 ? void 0 : userClaimData.index]); // user is in blob and contract marks as unclaimed\n\n  return Boolean(userClaimData && !isClaimedResult.loading && ((_isClaimedResult$resu = isClaimedResult.result) === null || _isClaimedResult$resu === void 0 ? void 0 : _isClaimedResult$resu[0]) === false);\n}\nexport function useUserUnclaimedAmount(account) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userClaimData = useUserClaimData(account);\n  const canClaim = useUserHasAvailableClaim(account);\n  const uni = chainId ? UNI[chainId] : undefined;\n  if (!uni) return undefined;\n\n  if (!canClaim || !userClaimData) {\n    return new TokenAmount(uni, JSBI.BigInt(0));\n  }\n\n  return new TokenAmount(uni, JSBI.BigInt(userClaimData.amount));\n}\nexport function useClaimCallback(account) {\n  // get claim data for this account\n  const {\n    library,\n    chainId\n  } = useActiveWeb3React();\n  const claimData = useUserClaimData(account); // used for popup summary\n\n  const unClaimedAmount = useUserUnclaimedAmount(account);\n  const addTransaction = useTransactionAdder();\n  const distributorContract = useMerkleDistributorContract();\n\n  const claimCallback = async function () {\n    if (!claimData || !account || !library || !chainId || !distributorContract) return;\n    const args = [claimData.index, account, claimData.amount, claimData.proof];\n    return distributorContract.estimateGas['claim'](...args, {}).then(estimatedGasLimit => {\n      return distributorContract.claim(...args, {\n        value: null,\n        gasLimit: calculateGasMargin(estimatedGasLimit)\n      }).then(response => {\n        addTransaction(response, {\n          summary: `Claimed ${unClaimedAmount === null || unClaimedAmount === void 0 ? void 0 : unClaimedAmount.toSignificant(4)} UNI`,\n          claim: {\n            recipient: account\n          }\n        });\n        return response.hash;\n      });\n    });\n  };\n\n  return {\n    claimCallback\n  };\n}","map":{"version":3,"sources":["C:/Users/Ulyss/chimpswap/uniswap-interface-main/src/state/claim/hooks.ts"],"names":["UNI","TokenAmount","JSBI","useEffect","useState","useActiveWeb3React","useMerkleDistributorContract","useSingleCallResult","calculateGasMargin","isAddress","useTransactionAdder","CLAIM_PROMISES","fetchClaim","account","chainId","formatted","Promise","reject","Error","key","fetch","body","JSON","stringify","address","headers","method","then","res","ok","json","console","log","catch","error","useUserClaimData","claimInfo","setClaimInfo","accountClaimInfo","undefined","useUserHasAvailableClaim","userClaimData","distributorContract","isClaimedResult","index","Boolean","loading","result","useUserUnclaimedAmount","canClaim","uni","BigInt","amount","useClaimCallback","library","claimData","unClaimedAmount","addTransaction","claimCallback","args","proof","estimateGas","estimatedGasLimit","claim","value","gasLimit","response","summary","toSignificant","recipient","hash"],"mappings":"AAAA,SAASA,GAAT,QAAoB,yBAApB;AACA,SAASC,WAAT,EAAsBC,IAAtB,QAA2C,cAA3C;AAEA,SAASC,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AACA,SAASC,kBAAT,QAAmC,aAAnC;AACA,SAASC,4BAAT,QAA6C,yBAA7C;AACA,SAASC,mBAAT,QAAoC,oBAApC;AACA,SAASC,kBAAT,EAA6BC,SAA7B,QAA8C,aAA9C;AACA,SAASC,mBAAT,QAAoC,uBAApC;AAaA,MAAMC,cAAgE,GAAG,EAAzE,C,CAEA;;AACA,SAASC,UAAT,CAAoBC,OAApB,EAAqCC,OAArC,EAAsF;AAAA;;AACpF,QAAMC,SAAS,GAAGN,SAAS,CAACI,OAAD,CAA3B;AACA,MAAI,CAACE,SAAL,EAAgB,OAAOC,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,iBAAV,CAAf,CAAP;AAChB,QAAMC,GAAG,GAAI,GAAEL,OAAQ,IAAGD,OAAQ,EAAlC;AAEA,SAAQF,cAAc,CAACQ,GAAD,CAAd,0BACNR,cAAc,CAACQ,GAAD,CADR,qEAENC,KAAK,CAAC,4CAAD,EAA+C;AAClDC,IAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AAAET,MAAAA,OAAF;AAAWU,MAAAA,OAAO,EAAET;AAApB,KAAf,CAD4C;AAElDU,IAAAA,OAAO,EAAE;AACP,sBAAgB,kBADT;AAEP,yBAAmB;AAFZ,KAFyC;AAMlDC,IAAAA,MAAM,EAAE;AAN0C,GAA/C,CAAL,CAQGC,IARH,CAQQC,GAAG,IAAKA,GAAG,CAACC,EAAJ,GAASD,GAAG,CAACE,IAAJ,EAAT,GAAsBC,OAAO,CAACC,GAAR,CAAa,wBAAuBjB,SAAU,gBAAeD,OAAQ,EAArE,CARtC,EASGmB,KATH,CASSC,KAAK,IAAIH,OAAO,CAACG,KAAR,CAAc,0BAAd,EAA0CA,KAA1C,CATlB,CAFF;AAYD,C,CAED;AACA;;;AACA,OAAO,SAASC,gBAAT,CAA0BtB,OAA1B,EAAgG;AACrG,QAAM;AAAEC,IAAAA;AAAF,MAAcT,kBAAkB,EAAtC;AAEA,QAAMc,GAAG,GAAI,GAAEL,OAAQ,IAAGD,OAAQ,EAAlC;AACA,QAAM,CAACuB,SAAD,EAAYC,YAAZ,IAA4BjC,QAAQ,CAA0C,EAA1C,CAA1C;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACU,OAAD,IAAY,CAACC,OAAjB,EAA0B;AAC1BF,IAAAA,UAAU,CAACC,OAAD,EAAUC,OAAV,CAAV,CAA6Ba,IAA7B,CAAkCW,gBAAgB,IAChDD,YAAY,CAACD,SAAS,IAAI;AACxB,aAAO,EACL,GAAGA,SADE;AAEL,SAACjB,GAAD,GAAOmB;AAFF,OAAP;AAID,KALW,CADd;AAQD,GAVQ,EAUN,CAACzB,OAAD,EAAUC,OAAV,EAAmBK,GAAnB,CAVM,CAAT;AAYA,SAAON,OAAO,IAAIC,OAAX,GAAqBsB,SAAS,CAACjB,GAAD,CAA9B,GAAsCoB,SAA7C;AACD,C,CAED;;AACA,OAAO,SAASC,wBAAT,CAAkC3B,OAAlC,EAA+E;AAAA;;AACpF,QAAM4B,aAAa,GAAGN,gBAAgB,CAACtB,OAAD,CAAtC;AACA,QAAM6B,mBAAmB,GAAGpC,4BAA4B,EAAxD;AACA,QAAMqC,eAAe,GAAGpC,mBAAmB,CAACmC,mBAAD,EAAsB,WAAtB,EAAmC,CAACD,aAAD,aAACA,aAAD,uBAACA,aAAa,CAAEG,KAAhB,CAAnC,CAA3C,CAHoF,CAIpF;;AACA,SAAOC,OAAO,CAACJ,aAAa,IAAI,CAACE,eAAe,CAACG,OAAlC,IAA6C,0BAAAH,eAAe,CAACI,MAAhB,gFAAyB,CAAzB,OAAgC,KAA9E,CAAd;AACD;AAED,OAAO,SAASC,sBAAT,CAAgCnC,OAAhC,EAA6F;AAClG,QAAM;AAAEC,IAAAA;AAAF,MAAcT,kBAAkB,EAAtC;AACA,QAAMoC,aAAa,GAAGN,gBAAgB,CAACtB,OAAD,CAAtC;AACA,QAAMoC,QAAQ,GAAGT,wBAAwB,CAAC3B,OAAD,CAAzC;AAEA,QAAMqC,GAAG,GAAGpC,OAAO,GAAGd,GAAG,CAACc,OAAD,CAAN,GAAkByB,SAArC;AACA,MAAI,CAACW,GAAL,EAAU,OAAOX,SAAP;;AACV,MAAI,CAACU,QAAD,IAAa,CAACR,aAAlB,EAAiC;AAC/B,WAAO,IAAIxC,WAAJ,CAAgBiD,GAAhB,EAAqBhD,IAAI,CAACiD,MAAL,CAAY,CAAZ,CAArB,CAAP;AACD;;AACD,SAAO,IAAIlD,WAAJ,CAAgBiD,GAAhB,EAAqBhD,IAAI,CAACiD,MAAL,CAAYV,aAAa,CAACW,MAA1B,CAArB,CAAP;AACD;AAED,OAAO,SAASC,gBAAT,CACLxC,OADK,EAIL;AACA;AACA,QAAM;AAAEyC,IAAAA,OAAF;AAAWxC,IAAAA;AAAX,MAAuBT,kBAAkB,EAA/C;AACA,QAAMkD,SAAS,GAAGpB,gBAAgB,CAACtB,OAAD,CAAlC,CAHA,CAKA;;AACA,QAAM2C,eAAwC,GAAGR,sBAAsB,CAACnC,OAAD,CAAvE;AACA,QAAM4C,cAAc,GAAG/C,mBAAmB,EAA1C;AACA,QAAMgC,mBAAmB,GAAGpC,4BAA4B,EAAxD;;AAEA,QAAMoD,aAAa,GAAG,kBAAiB;AACrC,QAAI,CAACH,SAAD,IAAc,CAAC1C,OAAf,IAA0B,CAACyC,OAA3B,IAAsC,CAACxC,OAAvC,IAAkD,CAAC4B,mBAAvD,EAA4E;AAE5E,UAAMiB,IAAI,GAAG,CAACJ,SAAS,CAACX,KAAX,EAAkB/B,OAAlB,EAA2B0C,SAAS,CAACH,MAArC,EAA6CG,SAAS,CAACK,KAAvD,CAAb;AAEA,WAAOlB,mBAAmB,CAACmB,WAApB,CAAgC,OAAhC,EAAyC,GAAGF,IAA5C,EAAkD,EAAlD,EAAsDhC,IAAtD,CAA2DmC,iBAAiB,IAAI;AACrF,aAAOpB,mBAAmB,CACvBqB,KADI,CACE,GAAGJ,IADL,EACW;AAAEK,QAAAA,KAAK,EAAE,IAAT;AAAeC,QAAAA,QAAQ,EAAEzD,kBAAkB,CAACsD,iBAAD;AAA3C,OADX,EAEJnC,IAFI,CAEEuC,QAAD,IAAmC;AACvCT,QAAAA,cAAc,CAACS,QAAD,EAAW;AACvBC,UAAAA,OAAO,EAAG,WAAUX,eAAX,aAAWA,eAAX,uBAAWA,eAAe,CAAEY,aAAjB,CAA+B,CAA/B,CAAkC,MAD/B;AAEvBL,UAAAA,KAAK,EAAE;AAAEM,YAAAA,SAAS,EAAExD;AAAb;AAFgB,SAAX,CAAd;AAIA,eAAOqD,QAAQ,CAACI,IAAhB;AACD,OARI,CAAP;AASD,KAVM,CAAP;AAWD,GAhBD;;AAkBA,SAAO;AAAEZ,IAAAA;AAAF,GAAP;AACD","sourcesContent":["import { UNI } from './../../constants/index'\nimport { TokenAmount, JSBI, ChainId } from '@uniswap/sdk'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { useEffect, useState } from 'react'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMerkleDistributorContract } from '../../hooks/useContract'\nimport { useSingleCallResult } from '../multicall/hooks'\nimport { calculateGasMargin, isAddress } from '../../utils'\nimport { useTransactionAdder } from '../transactions/hooks'\n\ninterface UserClaimData {\n  index: number\n  amount: string\n  proof: string[]\n  flags?: {\n    isSOCKS: boolean\n    isLP: boolean\n    isUser: boolean\n  }\n}\n\nconst CLAIM_PROMISES: { [key: string]: Promise<UserClaimData | null> } = {}\n\n// returns the claim for the given address, or null if not valid\nfunction fetchClaim(account: string, chainId: ChainId): Promise<UserClaimData | null> {\n  const formatted = isAddress(account)\n  if (!formatted) return Promise.reject(new Error('Invalid address'))\n  const key = `${chainId}:${account}`\n\n  return (CLAIM_PROMISES[key] =\n    CLAIM_PROMISES[key] ??\n    fetch('https://merkle-drop-1.uniswap.workers.dev/', {\n      body: JSON.stringify({ chainId, address: formatted }),\n      headers: {\n        'Content-Type': 'application/json',\n        'Referrer-Policy': 'no-referrer'\n      },\n      method: 'POST'\n    })\n      .then(res => (res.ok ? res.json() : console.log(`No claim for account ${formatted} on chain ID ${chainId}`)))\n      .catch(error => console.error('Failed to get claim data', error)))\n}\n\n// parse distributorContract blob and detect if user has claim data\n// null means we know it does not\nexport function useUserClaimData(account: string | null | undefined): UserClaimData | null | undefined {\n  const { chainId } = useActiveWeb3React()\n\n  const key = `${chainId}:${account}`\n  const [claimInfo, setClaimInfo] = useState<{ [key: string]: UserClaimData | null }>({})\n\n  useEffect(() => {\n    if (!account || !chainId) return\n    fetchClaim(account, chainId).then(accountClaimInfo =>\n      setClaimInfo(claimInfo => {\n        return {\n          ...claimInfo,\n          [key]: accountClaimInfo\n        }\n      })\n    )\n  }, [account, chainId, key])\n\n  return account && chainId ? claimInfo[key] : undefined\n}\n\n// check if user is in blob and has not yet claimed UNI\nexport function useUserHasAvailableClaim(account: string | null | undefined): boolean {\n  const userClaimData = useUserClaimData(account)\n  const distributorContract = useMerkleDistributorContract()\n  const isClaimedResult = useSingleCallResult(distributorContract, 'isClaimed', [userClaimData?.index])\n  // user is in blob and contract marks as unclaimed\n  return Boolean(userClaimData && !isClaimedResult.loading && isClaimedResult.result?.[0] === false)\n}\n\nexport function useUserUnclaimedAmount(account: string | null | undefined): TokenAmount | undefined {\n  const { chainId } = useActiveWeb3React()\n  const userClaimData = useUserClaimData(account)\n  const canClaim = useUserHasAvailableClaim(account)\n\n  const uni = chainId ? UNI[chainId] : undefined\n  if (!uni) return undefined\n  if (!canClaim || !userClaimData) {\n    return new TokenAmount(uni, JSBI.BigInt(0))\n  }\n  return new TokenAmount(uni, JSBI.BigInt(userClaimData.amount))\n}\n\nexport function useClaimCallback(\n  account: string | null | undefined\n): {\n  claimCallback: () => Promise<string>\n} {\n  // get claim data for this account\n  const { library, chainId } = useActiveWeb3React()\n  const claimData = useUserClaimData(account)\n\n  // used for popup summary\n  const unClaimedAmount: TokenAmount | undefined = useUserUnclaimedAmount(account)\n  const addTransaction = useTransactionAdder()\n  const distributorContract = useMerkleDistributorContract()\n\n  const claimCallback = async function() {\n    if (!claimData || !account || !library || !chainId || !distributorContract) return\n\n    const args = [claimData.index, account, claimData.amount, claimData.proof]\n\n    return distributorContract.estimateGas['claim'](...args, {}).then(estimatedGasLimit => {\n      return distributorContract\n        .claim(...args, { value: null, gasLimit: calculateGasMargin(estimatedGasLimit) })\n        .then((response: TransactionResponse) => {\n          addTransaction(response, {\n            summary: `Claimed ${unClaimedAmount?.toSignificant(4)} UNI`,\n            claim: { recipient: account }\n          })\n          return response.hash\n        })\n    })\n  }\n\n  return { claimCallback }\n}\n"]},"metadata":{},"sourceType":"module"}