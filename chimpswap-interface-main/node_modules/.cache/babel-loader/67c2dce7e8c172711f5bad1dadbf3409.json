{"ast":null,"code":"import { AddressZero } from '@ethersproject/constants';\nimport { ETHER, JSBI, Pair, Route, Token, TokenAmount, Trade, TradeType, WETH } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useActiveWeb3React } from '../hooks';\nimport { useAllTokens } from '../hooks/Tokens';\nimport { useV1FactoryContract } from '../hooks/useContract';\nimport { Version } from '../hooks/useToggledVersion';\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks';\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks';\nexport function useV1ExchangeAddress(tokenAddress) {\n  var _useSingleCallResult, _useSingleCallResult$;\n\n  const contract = useV1FactoryContract();\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress]);\n  return (_useSingleCallResult = useSingleCallResult(contract, 'getExchange', inputs)) === null || _useSingleCallResult === void 0 ? void 0 : (_useSingleCallResult$ = _useSingleCallResult.result) === null || _useSingleCallResult$ === void 0 ? void 0 : _useSingleCallResult$[0];\n}\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount, tokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount));\n  }\n\n}\n\nfunction useMockV1Pair(inputCurrency) {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined;\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]));\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token === null || token === void 0 ? void 0 : token.address);\n  const tokenBalance = useTokenBalance(v1PairAddress, token);\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress !== null && v1PairAddress !== void 0 ? v1PairAddress : ''];\n  return useMemo(() => token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined, [ETHBalance, inputCurrency, token, tokenBalance]);\n} // returns all v1 exchange addresses in the user's token list\n\n\nexport function useAllTokenV1Exchanges() {\n  const allTokens = useAllTokens();\n  const factory = useV1FactoryContract();\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens]);\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD);\n  return useMemo(() => {\n    var _data$reduce;\n\n    return (_data$reduce = data === null || data === void 0 ? void 0 : data.reduce((memo, {\n      result\n    }, ix) => {\n      if ((result === null || result === void 0 ? void 0 : result[0]) && result[0] !== AddressZero) {\n        memo[result[0]] = allTokens[args[ix][0]];\n      }\n\n      return memo;\n    }, {})) !== null && _data$reduce !== void 0 ? _data$reduce : {};\n  }, [allTokens, args, data]);\n} // returns whether any of the tokens in the user's token list have liquidity on v1\n\nexport function useUserHasLiquidityInAllTokens() {\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const exchanges = useAllTokenV1Exchanges();\n  const v1ExchangeLiquidityTokens = useMemo(() => chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [], [chainId, exchanges]);\n  const balances = useTokenBalances(account !== null && account !== void 0 ? account : undefined, v1ExchangeLiquidityTokens);\n  return useMemo(() => Object.keys(balances).some(tokenAddress => {\n    var _balances$tokenAddres;\n\n    const b = (_balances$tokenAddres = balances[tokenAddress]) === null || _balances$tokenAddres === void 0 ? void 0 : _balances$tokenAddres.raw;\n    return b && JSBI.greaterThan(b, JSBI.BigInt(0));\n  }), [balances]);\n}\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\n\nexport function useV1Trade(isExactIn, inputCurrency, outputCurrency, exactAmount) {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency);\n  const outputPair = useMockV1Pair(outputCurrency);\n  const inputIsETH = inputCurrency === ETHER;\n  const outputIsETH = outputCurrency === ETHER; // construct a direct or through ETH v1 route\n\n  let pairs = [];\n\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair];\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair];\n  } // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n      pairs = [inputPair, outputPair];\n    }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency);\n  let v1Trade;\n\n  try {\n    v1Trade = route && exactAmount ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT) : undefined;\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error);\n  }\n\n  return v1Trade;\n}\nexport function getTradeVersion(trade) {\n  var _trade$route, _trade$route$pairs;\n\n  const isV1 = trade === null || trade === void 0 ? void 0 : (_trade$route = trade.route) === null || _trade$route === void 0 ? void 0 : (_trade$route$pairs = _trade$route.pairs) === null || _trade$route$pairs === void 0 ? void 0 : _trade$route$pairs.some(pair => pair instanceof MockV1Pair);\n  if (isV1) return Version.v1;\n  if (isV1 === false) return Version.v2;\n  return undefined;\n} // returns the v1 exchange against which a trade should be executed\n\nexport function useV1TradeExchangeAddress(trade) {\n  const tokenAddress = useMemo(() => {\n    if (!trade) return undefined;\n    const isV1 = getTradeVersion(trade) === Version.v1;\n    if (!isV1) return undefined;\n    return trade.inputAmount instanceof TokenAmount ? trade.inputAmount.token.address : trade.outputAmount instanceof TokenAmount ? trade.outputAmount.token.address : undefined;\n  }, [trade]);\n  return useV1ExchangeAddress(tokenAddress);\n}","map":{"version":3,"sources":["C:/Users/Ulyss/chimpswap/uniswap-interface-main/src/data/V1.ts"],"names":["AddressZero","ETHER","JSBI","Pair","Route","Token","TokenAmount","Trade","TradeType","WETH","useMemo","useActiveWeb3React","useAllTokens","useV1FactoryContract","Version","NEVER_RELOAD","useSingleCallResult","useSingleContractMultipleData","useETHBalances","useTokenBalance","useTokenBalances","useV1ExchangeAddress","tokenAddress","contract","inputs","result","MockV1Pair","constructor","etherAmount","tokenAmount","token","chainId","useMockV1Pair","inputCurrency","undefined","isWETH","Boolean","equals","v1PairAddress","address","tokenBalance","ETHBalance","raw","useAllTokenV1Exchanges","allTokens","factory","args","Object","keys","map","data","reduce","memo","ix","useUserHasLiquidityInAllTokens","account","exchanges","v1ExchangeLiquidityTokens","balances","some","b","greaterThan","BigInt","useV1Trade","isExactIn","outputCurrency","exactAmount","inputPair","outputPair","inputIsETH","outputIsETH","pairs","route","length","v1Trade","EXACT_INPUT","EXACT_OUTPUT","error","console","debug","getTradeVersion","trade","isV1","pair","v1","v2","useV1TradeExchangeAddress","inputAmount","outputAmount"],"mappings":"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","sourcesContent":["import { AddressZero } from '@ethersproject/constants'\nimport {\n  BigintIsh,\n  Currency,\n  CurrencyAmount,\n  ETHER,\n  JSBI,\n  Pair,\n  Route,\n  Token,\n  TokenAmount,\n  Trade,\n  TradeType,\n  WETH\n} from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { useActiveWeb3React } from '../hooks'\nimport { useAllTokens } from '../hooks/Tokens'\nimport { useV1FactoryContract } from '../hooks/useContract'\nimport { Version } from '../hooks/useToggledVersion'\nimport { NEVER_RELOAD, useSingleCallResult, useSingleContractMultipleData } from '../state/multicall/hooks'\nimport { useETHBalances, useTokenBalance, useTokenBalances } from '../state/wallet/hooks'\n\nexport function useV1ExchangeAddress(tokenAddress?: string): string | undefined {\n  const contract = useV1FactoryContract()\n\n  const inputs = useMemo(() => [tokenAddress], [tokenAddress])\n  return useSingleCallResult(contract, 'getExchange', inputs)?.result?.[0]\n}\n\nexport class MockV1Pair extends Pair {\n  constructor(etherAmount: BigintIsh, tokenAmount: TokenAmount) {\n    super(tokenAmount, new TokenAmount(WETH[tokenAmount.token.chainId], etherAmount))\n  }\n}\n\nfunction useMockV1Pair(inputCurrency?: Currency): MockV1Pair | undefined {\n  const token = inputCurrency instanceof Token ? inputCurrency : undefined\n\n  const isWETH = Boolean(token && token.equals(WETH[token.chainId]))\n  const v1PairAddress = useV1ExchangeAddress(isWETH ? undefined : token?.address)\n  const tokenBalance = useTokenBalance(v1PairAddress, token)\n  const ETHBalance = useETHBalances([v1PairAddress])[v1PairAddress ?? '']\n\n  return useMemo(\n    () =>\n      token && tokenBalance && ETHBalance && inputCurrency ? new MockV1Pair(ETHBalance.raw, tokenBalance) : undefined,\n    [ETHBalance, inputCurrency, token, tokenBalance]\n  )\n}\n\n// returns all v1 exchange addresses in the user's token list\nexport function useAllTokenV1Exchanges(): { [exchangeAddress: string]: Token } {\n  const allTokens = useAllTokens()\n  const factory = useV1FactoryContract()\n  const args = useMemo(() => Object.keys(allTokens).map(tokenAddress => [tokenAddress]), [allTokens])\n\n  const data = useSingleContractMultipleData(factory, 'getExchange', args, NEVER_RELOAD)\n\n  return useMemo(\n    () =>\n      data?.reduce<{ [exchangeAddress: string]: Token }>((memo, { result }, ix) => {\n        if (result?.[0] && result[0] !== AddressZero) {\n          memo[result[0]] = allTokens[args[ix][0]]\n        }\n        return memo\n      }, {}) ?? {},\n    [allTokens, args, data]\n  )\n}\n\n// returns whether any of the tokens in the user's token list have liquidity on v1\nexport function useUserHasLiquidityInAllTokens(): boolean | undefined {\n  const { account, chainId } = useActiveWeb3React()\n\n  const exchanges = useAllTokenV1Exchanges()\n\n  const v1ExchangeLiquidityTokens = useMemo(\n    () =>\n      chainId ? Object.keys(exchanges).map(address => new Token(chainId, address, 18, 'UNI-V1', 'Uniswap V1')) : [],\n    [chainId, exchanges]\n  )\n\n  const balances = useTokenBalances(account ?? undefined, v1ExchangeLiquidityTokens)\n\n  return useMemo(\n    () =>\n      Object.keys(balances).some(tokenAddress => {\n        const b = balances[tokenAddress]?.raw\n        return b && JSBI.greaterThan(b, JSBI.BigInt(0))\n      }),\n    [balances]\n  )\n}\n\n/**\n * Returns the trade to execute on V1 to go between input and output token\n */\nexport function useV1Trade(\n  isExactIn?: boolean,\n  inputCurrency?: Currency,\n  outputCurrency?: Currency,\n  exactAmount?: CurrencyAmount\n): Trade | undefined {\n  // get the mock v1 pairs\n  const inputPair = useMockV1Pair(inputCurrency)\n  const outputPair = useMockV1Pair(outputCurrency)\n\n  const inputIsETH = inputCurrency === ETHER\n  const outputIsETH = outputCurrency === ETHER\n\n  // construct a direct or through ETH v1 route\n  let pairs: Pair[] = []\n  if (inputIsETH && outputPair) {\n    pairs = [outputPair]\n  } else if (outputIsETH && inputPair) {\n    pairs = [inputPair]\n  }\n  // if neither are ETH, it's token-to-token (if they both exist)\n  else if (inputPair && outputPair) {\n    pairs = [inputPair, outputPair]\n  }\n\n  const route = inputCurrency && pairs && pairs.length > 0 && new Route(pairs, inputCurrency, outputCurrency)\n  let v1Trade: Trade | undefined\n  try {\n    v1Trade =\n      route && exactAmount\n        ? new Trade(route, exactAmount, isExactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT)\n        : undefined\n  } catch (error) {\n    console.debug('Failed to create V1 trade', error)\n  }\n  return v1Trade\n}\n\nexport function getTradeVersion(trade?: Trade): Version | undefined {\n  const isV1 = trade?.route?.pairs?.some(pair => pair instanceof MockV1Pair)\n  if (isV1) return Version.v1\n  if (isV1 === false) return Version.v2\n  return undefined\n}\n\n// returns the v1 exchange against which a trade should be executed\nexport function useV1TradeExchangeAddress(trade: Trade | undefined): string | undefined {\n  const tokenAddress: string | undefined = useMemo(() => {\n    if (!trade) return undefined\n    const isV1 = getTradeVersion(trade) === Version.v1\n    if (!isV1) return undefined\n    return trade.inputAmount instanceof TokenAmount\n      ? trade.inputAmount.token.address\n      : trade.outputAmount instanceof TokenAmount\n      ? trade.outputAmount.token.address\n      : undefined\n  }, [trade])\n  return useV1ExchangeAddress(tokenAddress)\n}\n"]},"metadata":{},"sourceType":"module"}