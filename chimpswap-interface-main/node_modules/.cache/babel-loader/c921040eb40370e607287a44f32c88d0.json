{"ast":null,"code":"import { MaxUint256 } from '@ethersproject/constants';\nimport { ETHER, Token, TradeType } from '@uniswap/sdk';\nimport { getTradeVersion } from '../data/V1';\nimport { Version } from '../hooks/useToggledVersion';\n\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`;\n}\n/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */\n\n\nexport default function v1SwapArguments(trade, options) {\n  if (getTradeVersion(trade) !== Version.v1) {\n    throw new Error('invalid trade version');\n  }\n\n  if (trade.route.pairs.length > 2) {\n    throw new Error('too many pairs');\n  }\n\n  const isExactIn = trade.tradeType === TradeType.EXACT_INPUT;\n  const inputETH = trade.inputAmount.currency === ETHER;\n  const outputETH = trade.outputAmount.currency === ETHER;\n  if (inputETH && outputETH) throw new Error('ETHER to ETHER');\n  const minimumAmountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n  const maximumAmountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n  const deadline = `0x${options.deadline.toString(16)}`;\n\n  if (isExactIn) {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferInput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      };\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, deadline, options.recipient],\n        value: '0x0'\n      };\n    } else {\n      const outputToken = trade.outputAmount.currency; // should never happen, needed for type check\n\n      if (!(outputToken instanceof Token)) {\n        throw new Error('token to token');\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, '0x1', deadline, options.recipient, outputToken.address],\n        value: '0x0'\n      };\n    }\n  } else {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferOutput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      };\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, deadline, options.recipient],\n        value: '0x0'\n      };\n    } else {\n      const output = trade.outputAmount.currency;\n\n      if (!(output instanceof Token)) {\n        throw new Error('invalid output amount currency');\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, MaxUint256.toHexString(), deadline, options.recipient, output.address],\n        value: '0x0'\n      };\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Ulyss/chimpswap/uniswap-interface-main/src/utils/v1SwapArguments.ts"],"names":["MaxUint256","ETHER","Token","TradeType","getTradeVersion","Version","toHex","currencyAmount","raw","toString","v1SwapArguments","trade","options","v1","Error","route","pairs","length","isExactIn","tradeType","EXACT_INPUT","inputETH","inputAmount","currency","outputETH","outputAmount","minimumAmountOut","allowedSlippage","maximumAmountIn","deadline","methodName","args","recipient","value","outputToken","address","output","toHexString"],"mappings":"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","sourcesContent":["import { MaxUint256 } from '@ethersproject/constants'\nimport { CurrencyAmount, ETHER, SwapParameters, Token, Trade, TradeOptionsDeadline, TradeType } from '@uniswap/sdk'\nimport { getTradeVersion } from '../data/V1'\nimport { Version } from '../hooks/useToggledVersion'\n\nfunction toHex(currencyAmount: CurrencyAmount): string {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\n/**\n * Get the arguments to make for a swap\n * @param trade trade to get v1 arguments for swapping\n * @param options options for swapping\n */\nexport default function v1SwapArguments(\n  trade: Trade,\n  options: Omit<TradeOptionsDeadline, 'feeOnTransfer'>\n): SwapParameters {\n  if (getTradeVersion(trade) !== Version.v1) {\n    throw new Error('invalid trade version')\n  }\n  if (trade.route.pairs.length > 2) {\n    throw new Error('too many pairs')\n  }\n  const isExactIn = trade.tradeType === TradeType.EXACT_INPUT\n  const inputETH = trade.inputAmount.currency === ETHER\n  const outputETH = trade.outputAmount.currency === ETHER\n  if (inputETH && outputETH) throw new Error('ETHER to ETHER')\n  const minimumAmountOut = toHex(trade.minimumAmountOut(options.allowedSlippage))\n  const maximumAmountIn = toHex(trade.maximumAmountIn(options.allowedSlippage))\n  const deadline = `0x${options.deadline.toString(16)}`\n  if (isExactIn) {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferInput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const outputToken = trade.outputAmount.currency\n      // should never happen, needed for type check\n      if (!(outputToken instanceof Token)) {\n        throw new Error('token to token')\n      }\n      return {\n        methodName: 'tokenToTokenTransferInput',\n        args: [maximumAmountIn, minimumAmountOut, '0x1', deadline, options.recipient, outputToken.address],\n        value: '0x0'\n      }\n    }\n  } else {\n    if (inputETH) {\n      return {\n        methodName: 'ethToTokenTransferOutput',\n        args: [minimumAmountOut, deadline, options.recipient],\n        value: maximumAmountIn\n      }\n    } else if (outputETH) {\n      return {\n        methodName: 'tokenToEthTransferOutput',\n        args: [minimumAmountOut, maximumAmountIn, deadline, options.recipient],\n        value: '0x0'\n      }\n    } else {\n      const output = trade.outputAmount.currency\n      if (!(output instanceof Token)) {\n        throw new Error('invalid output amount currency')\n      }\n\n      return {\n        methodName: 'tokenToTokenTransferOutput',\n        args: [\n          minimumAmountOut,\n          maximumAmountIn,\n          MaxUint256.toHexString(),\n          deadline,\n          options.recipient,\n          output.address\n        ],\n        value: '0x0'\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}